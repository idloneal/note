# 基础

* 如果你在一个java源代码中引用另外一个Java源代码，然后只用Javac编译你的第一个文件，那个被引用的源文件也会被自动编译好。

## 命名规则

| 类    型 | 书写规则     | 举	例       |
| -------- | ------------ | -------------- |
| 变量名   | 小写驼峰规则 | sumNum         |
| 类名     | 大写驼峰规则 | SumNum         |
| 包名     | 全部小写     | de.myjava.test |
| 常量名   | 全部大写     | PAI            |



## 逻辑运算符

| 运算符 | 符号含义     | 注解                                             |
| ------ | ------------ | ------------------------------------------------ |
| ！     | 取反运算     | 对布尔值取反，真的变为假。假的变为真             |
| &      | 逻辑与(位与) | 当两个表达式的值同为真时，运算结果为真           |
| \|     | 逻辑或(位或) | 当两个表达式中的任意一个值为真时，运算结果为真   |
| &&     | 逻辑与       | 当第一个表达式的值为假时，结束运算；运算结果为假 |
| \|\|   | 逻辑或       | 当第一个表达式的值为真时，结束运算；运算结果为真 |
| ^      | 异或         | 当两个表达式的值不相同时，运算结果为真           |



## 包装类

| 基本数据类 | (包装类)    |
| ---------- | ----------- |
| byte       | (Byte)      |
| short      | (Short)     |
| char       | (Character) |
| int        | (Integer)   |
| float      | (Float)     |
| double     | (Double)    |
| boolean    | (Boolean)   |

​		String → 包装类 (原始数据类型 → 包装类) : `Integer`.valueOf()
​		String → 原始数据类型 ：``Integer`.parseInt()
​		包装类 → 原始数据类型 ： `xx`.`int`Value()		



## 字符串

| 方法                                                         | 用法                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| charAt(index)                                                | 返回字符串中 第index个 字符                                  |
| substring( start[,end] )                                     | 分割字符串从start开始到end结束 返回的是字符串类型            |
| Arrays.toString()                                            | 可以把字符串数组转换成一个字符串                             |
| equals()                                                     | 进行字符串的比较 如果要忽略大小写用 equalsIgnoreCas()        |
| startsWith()                                                 | 比较两个字符串的前缀是否相同 `endWith()`比较后缀             |
| regionMatches(([boolean], int toffset, String other, intooffset, int len ) | 比较目标字符串中是否包含指定字符串 boolean为真忽略大小写<br />**toffset** -- 此字符串中子区域的起始偏移量。<br />**other** -- 字符串参数<br />**ooffset** -- 字符串参数中子区域的起始偏移量<br />**len** -- 要比较的字符数 |
| indexOf(char[,start])                                        | 放回指定的字符串或者字符在目标字符串首次出现的位置 start表示从此位置开始查找<br /> 如果没有找到 返回值为 -1 |
| lastIndexOf(char[,strat])                                    | 和`indexOf() `比从右边开始查找                               |
| contains()                                                   | 查看目标目标字符串是否包含指定字符串或字符                   |
| replace(a,b)                                                 | 把字符串中的a替换成b  返回替换后的字符串或字符<br />如果值替换第一个用`replaceFisrt()`<br />`replaceAll()`支持正则表达式 |
| intern()                                                     | 检测字符串池中有无对象的引用：有返回这个对象的引用 没有就生成对象的同时在池中野产生一个该对象的引用 |
| toString([int x])                                            | 将一个对象转变为字符串 如果写入参数x（2-36）可以将数字转换为其他进制数 |



## 可变字符串

| 方法               | 用法                                                         |
| ------------------ | ------------------------------------------------------------ |
| Stringbuffer(str)  | 创建一个内容为str的可变字符串 因为是动态的 最好事先分配好空间 str为数字时为其分配的空间 |
| StringBuilder(str) | 和`Stringbuffer()`类似 如果程序是在单线程下运行，或者是 不必考虑到线程同步问题，我们应该优先使用`StringBuilder` |
| append()           | 在字符串末尾追加 字符、原始类型数、对象                      |
| insert(num,)       | 在字符串第num个位置添加 字符、原始类型数、对象               |
| delete(start,end)  | 删除字符串的片段 如果删除指定字符最好使用`deleteCharAt()`    |
| reverse()          | 将字符串反向输出                                             |



## 对象

| 函数      | 用法                                                         |
| --------- | ------------------------------------------------------------ |
| public    | 申明为公共类型                                               |
| private   | 将其申明为私有类型 外界无法直接访问(一般是创建一个公共方法 `setWert()` `getWert()`来修改访问) |
| protecetd | 申明后的变量和方法只能被同一包中的类访问。(除非在其他包中的类是该成员所属的子类) |
| this      | 当前的对象 （python的self）                                  |
| final     | 申明变量值初始化后不能再被改变 一般用作创建类常量            |

### 访问权限汇总

| 访问修饰符 | 同一类的成员 | 同一包的其他类 | 同一包的子类 | 不同包的子类 | 不同包的非子类 |
| ---------- | ------------ | -------------- | ------------ | ------------ | -------------- |
| public     | T            | T              | T            | T            | T              |
| protected  | T            | T              | T            | T            | F              |
| 不加修饰符 | T            | T              | T            | F            | F              |
| private    | T            | F              | F            | F            | F              |



## 继承

| 函数              | 用法                                               |
| ----------------- | -------------------------------------------------- |
| 子类 extends 父类 | 让子类继承父类                                     |
| final             | 用此写的类或方法不能被继承                         |
| super.            | 调用父类的方法（不能在静态方法中使用）             |
| a instanceof A    | 左边的对象是否是它右边的类的实例（返回的是布尔值） |



## 抽象类和接口

| 关键字                       | 用法                         |
| ---------------------------- | ---------------------------- |
| abstract                     | 创建一个抽象类（无法实例化） |
| interface                    | 定义一个接口                 |
| implements                   | 实现一个接口                 |
| enum                         | 枚举常量                     |
| static final ****** static{} | 静态块                       |



## 数组、集合和映射

| 方法                                                         | 用法                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Arrays.copyOf(a,b)                                           | 将数组a复制到b(新尺寸的数组)中                               |
| Arrays.asList()                                              | 把数组转成链表                                               |
| java,util.Collection                                         | 所有元素的集合                                               |
| add(E element)                                               | 在集合中加入一个类型为E的元素。                              |
| clear()                                                      | 删除集合中的所有元素                                         |
| contains()                                                   | 检测一个元素是否属于这个集合                                 |
| remove()                                                     | 把一个元素移出集合，以供以后使用                             |
| size()                                                       | 获得集合中元素的个数                                         |
| List<包装类型>  xxx=   new xxx<>()<br />java9    List<包装类> xxx= List.of("元素") | 创建一个链表<br />用这种方法创建的是不可改变的               |
| Set<Interger> num = new HashSet<>() <br />Set<Interger> num = new TreeSet<>() <br />Set<Interger> num = Set.of(1,2,3,4)<br />.                                       new HashMap<>() | 创建一个集合<br />创建一个有序的集合<br /><br />创建一个字典 |
| addAll()                                                     | 获得两个集合的并集                                           |
| removeAll()                                                  | 获得两个集合的差集                                           |
| retainAll()                                                  | 获得两个集合的交集                                           |
| containsAll()                                                | 判断一个集合是否为另一个集合的子集                           |
| sort()                                                       | 对链表中所有的元素进行排序                                   |
| compare(a,b)                                                 | 比较ab的大小                                                 |
| put()                                                        | 字典中用put()代替add()                                       |
| get()                                                        | 可以获得一个键所对应的值                                     |
| KeySet()                                                     | 生成一个所有可用键的Set                                      |
| values()                                                     | 生成一个所有值的Collection                                   |



| 方法名           | 功能描述       |
| ---------------- | -------------- |
| Stack类          | 栈             |
| push()           | 添加一个元素   |
| peek()           | 查看栈顶元素   |
| pop()            | 弹出栈顶元素   |
| empty()          | 检查栈是否为空 |
| Queue类          | 队列           |
| add(),offer()    | 添加一个元素   |
| element(),peek() | 查看栈底元素   |
| remove(),poll()  | 弹出栈底元素   |

| compareTo() | 含义                             |
| ----------- | -------------------------------- |
| 0           | 如果对象对于它的属性是“相等”     |
| -1          | 如果当前对象比其他的对象“小一些” |
| 1           | 如果当前的对象比其他对象“大一些” |



### Lambda表达式

| 格式   |                                              |
| ------ | -------------------------------------------- |
| ->     | lambda操作符（箭头操作符）                   |
| ->左边 | lambda形参列表（接口中的抽象方法的形参列表） |
| ->右边 | lambda体 （重写的抽象方法的方法体）          |



## 异常

继承于标准函数库Exception。

| 方法    | 用法                     |
| ------- | ------------------------ |
| catch   | 捕获异常                 |
| finally | 块中的代码始终都会被执行 |



### 常见的运行时异常：

| 异常名称                       | 表述               |
| ------------------------------ | ------------------ |
| ArithmeticException            | 算术运算异常       |
| ArrayIndexOutOfBoundsException | 数组下角标越界异常 |
| ClassCastException             | 类型转换异常       |
| IllegalArgumentException       | 无效参数传递异常   |
| NumberFormatException          | 数字格式异常       |
| IllegalStateException          | 非法状态异常       |
| NullPointerException           | 空指针异常         |

















# 总结

## 变量和基本数据类型

* **变量**是临时储存的数据的容器
* 变量必须有个**数据类型**，数据类型在编译阶段就已经声明了
* 数据类型分为**原始数据类型**和**引用数据类型**
* 原始数据类型包括**数据类型、布尔值类型、字符类型**
* 数字类型包括**整数型**和**浮点型**，每个数字类型都有固定的**取值范围**

* 用`float`和`double`计算小数位的精确程度没有使用`BigDecimal`方法的精度高
* 数字类型之间可以**相互转换**
* 类型扩展(Widening)的意思是：把一个取值范围较小的变量类型转换成一个取值范围较大的变量
* 类型缩小(Narrowing)的意思是和类型扩展正好相反。在把变量的原始值转换到新的取值范围时必须格外小心
* 对于任何一个原始数据都有一个与之相对应的**包装类**，例如前面列表中提到的那些。除此之外，包装类提供了一些实用的**方法**和**常量**。在开发程序时，多关注**Java标准函数库**是非常有帮助的。

## Java流程控制语句

* 通过流程控制结构可以影响程序的**执行进程**。
* 如果需要根据布尔表达式的值来执行一段代码，那么就可以直接采用`if`语句
* 如果需要根据布尔表达式的值来执行一段代码或者其他某段代码，那么就可以采用`if else`语句。
* `switch`语句是`if`嵌套结构的一个替换形式。但是，`switch`不能对布尔表达式取值，只能转换成`int`型,以及字符串和枚举型数据.它的好处是在书写上也比`if else`语句结构**紧凑**一些.
* 如果想要**反复执行**某个代码块,可以使用循环结构:`while`循环、`do while`循环和`for`循环。
* `for`循环语句指代一个循环计数变量，其他的循环必须自己构建。
* 如果程序的控制流程过于复杂，最好是先编写一个**伪代码**，明确大致的步骤和结构后再实施编程。
* 伪代码的内容还可以作为**注释**出现在程序中，这样就增强了程序的可读性。

## 有关字符串的操作

* 字符串不可更改
* 对于字符串的动态操作要使用`StringBuilder`和`StringBuffer`
* 在循环中进行拼接字符串时，调用`StringBuilder`类中的方法比直接运用+运算符更有效率。所以尽量避免用+运算符拼接字符串。
* 为了更方便地使用字符串，Java引入了字符串池机制。
* 用new创建字符串时，字符串池完全被绕开，所以应该放弃用构造函数创建字符串。
* 使用`equals()`和`equalsIgnoreCase()`进行字符串比较的操作时，不要使用`==`运算符。
* 原则上不需要使用`StringBuffer`，因为`StringBuilder`的运算速度更快些。
* 字符串中的字符个数从数字0开始计算。

## 类、对象和方法

* 类是创建对象的**模板**
* 对象只能放在堆里
* **类变量**和**类方法**在创建类后就可以使用，**对象变量**和**对象方法**在创建这个类的对象之后才能使用
* 在给**对象变量赋值或取值时**，可以自己编写set和get方法，这样做增强了程序的兼容性。
* 在set方法中需要对输入参数进行有效性检测，也可以叫作**验证**。
* 所有的类都是由对象类（java.lang.object）衍生出来的，或者说，Object是所有类的父类。
* 每个类**至少有一个构造函数**。如果在一个类中没有编写构造函数的话，编译器会自动生成一个**标准构造函数**。
* 根据不同情况重写`toString()`方法。
* **对象**和**对象变量**储存在堆中，**方法**和**局部变量**储存在栈中。
* 用虚拟机（VisualVM）可以查看堆的使用情况。
* 在堆中，不再被引用的对象将被垃圾回收器删除；在不能及时回收内存空间时，可以调用`finalize()`方法来释放内存空间。

## 继承

* **继承**在面向对象程序设计中是个重要的概念，继承可以避免重复编写代码。
* 类的继承需要用到关键字`extends`
* Java中只支持单一继承，不接受多重继承！
* **继承**可以用在变量、方法和内部类。构造函数**不能继承**。
* 另外，如果子类和父类属于同一包，如`public`或者`protected`、包私有的类也可以继承。
* 如果一个类没有默认的构造函数，那么作为它的子类，必须明确指出调用该类的一个构造函数。
* 通过**方法重写**，子类可以根据自己的需要调整继承来的方法。
* 如果一个类中有多个同名的方法，只能通过参数的个数和类型的不同进行调用。这就叫做方法的**重载**。
* **转型**指的是类型之间的转换。
* **向下转型**是指在一个类中，高阶的类型向低阶的类型转换。
* **向上转型**与向下转型相反，低阶类型向高阶类型转换。
* 向下转型之前需要用到`instanceof`运算符检查类型转换时的可行性。

## 抽象类和接口

* **抽象类**使得类层次结构更加丰富，而且还可以为创建子类提供一个有效的模板。
* **接口**可以看作对象实例间的一个契约。一般来说，API可以看作系统间的一个契约。
* 抽象类不可以实例化
* 接口也不可以
* 假如一个类包含了一个抽象方法，那么这个类也必须是抽象的。
* 在定义接口时，只能定义**方法签名**，不能定义**方法体**（空方法）。
* 在接口中，所有方法的修饰符默认为`public`和`abstract`.
* 计时接口时`abstract`的，也不能说接口是抽象类。
* 接口**不包含构造函数**，抽象类可以包含构造函数。
* 用接口可以实现**Java禁止的多重继承关系**
* 针对接口编程时，可以先保持代码的灵活性，再考虑如何实现接口功能。
* 不可以在接口中使用常量，只能在**常量类**或者**枚举**中定义常量。
* **静态**和**非静态的成员类**，已经**局部类**和**匿名类**可以实现类的嵌套。尽管如此，也要慎用类的嵌套。除非是在特定的情况下，比如GUI编程。
* 不要受**设计模式**的影响。

## 数组、集合和映射

* 数组是从0开始计算的，如果条件允许的话，也可以不从0开始计算。
* 判断对象的相同性时不要使用 == 运算符，而要使用`equals()`方法。
* 实现`equals()`方法的时候要需要注意**四个重要特性**。
* 重写`equals()`方法时，需要重写`hashCode()`方法,否则将一直寻找。
* 合理地选择哈希码，否则寻找的过程会很长。
* 可以从集合中抽取数组（尽管如此，还是需要检测可行性）！
* 要牢记数组和集合的辅助方法！
* 如果只是**对一种数据排序**的话，可以使用`compareTo()`方法。但如果是对**不同种类的数据排序**，或者**不想改变已排好序的类中的内容**(比如函数库的一部分)，那么就只能用比较器接口(Comparator)
* 需要注意，Set中的值不能重复,Map中的键也是不可重复的！
* 队列和栈的工作方式类似，只不过是彼此相反的！

### lambda

* 函数式编程关注的是对象集合中的函数。
* 在Java 8中，这样的对象集合是通过`java.util.stream.Stream`来描述的，并且所有类都被封装在`java.util.stream`包中。
* 流中还定义了非常重要且出名的函数式编程的函数。
  * filter()方法，筛选流中的对象。
  * map()方法，把流中的一个对象定位到另一个对象上。
  * reduce()方法，把流中的对象简化为一个返回值。
* 所有的函数都应该提供一个lambda表达式作为参数。在Java中，这样的表达式被视为是匿名类的一个紧凑写法。
* 方法引用允许把方法作为参数传递给另外一个方法。





















































































